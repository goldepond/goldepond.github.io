---
layout: post
comments: true
title: UnityGame
categories: [C#,Unity]
---
# RunRunRun

## 프로젝트 소개
  본 프로젝트는 제 첫 자작게임이며 C#과 공부를 병행하며 진행되었습니다. 혼자 독학으로 관련 기술들을 학습한 이후 응용하여 제작한 개인 프로젝트이기 떄문에, 구멍은 많지만 개인적 만족감을 가지고 앞으로 나아가게 해준 프로젝트 입니다.
  
## 개발환경
  운영체제 : Android
  IDE : VisualStudio 2019
  개발엔진 : Unity 2020.2.1f1
  
## Description
*  쿠키런 형식의 달리고 뛰면서 더 높은 점수를 얻는 게임입니다.
*  유니티 엔진을 사용한 c#으로 제작되었습니다.
*  1인 개발 게임입니다.

## Related Sources

[RunRunRun깃허브](https://github.com/goldepond/RunBoyRun).
<br/>
<br/>

## 1 게임 소개
<br/>

![GameMenu](https://user-images.githubusercontent.com/37152976/114313345-1f8d7880-9b31-11eb-88f8-a8ac03d53e0d.gif)
<br/><br/>
### *  초기 기능
   *  4개의 캐릭터, 4개의 스타팅파워, 9개의 능력, 9개의 아이템으로 유저 경험을 다각화시켰습니다.
   *  캐릭터 탭에서는 4개의 캐릭터가 있습니다. 처음에는 첫번째 캐릭터만 해금되어 있지만, 스테이지를 클리어하면 순차적으로 해금됩니다.
   *  4개의 스타팅파워, 9개의 능력또한 순차적으로 해금됩니다. 스타팅  게임 시작시 자동으로 발동됩니다. 게임에서 발동되는 능력은 선택한 한가지 능력만 발동됩니다.
   *  각 스테이지마다 다른 아이템이 등장하며 아이템 탭에서는 이런 아이템의 효과를 증가시킬 수 있습니다.
   
   
![GameScene1](https://user-images.githubusercontent.com/37152976/114377965-329c5900-9bc2-11eb-8d93-76663f502447.gif)
### *  추가 기능
* 기본적으로 달리면 서서히 체력바가 줄어들며, 몬스터와 부딫혔을 경우 체력이 대폭 줄어듭니다.
* 몬스터의 머리부분을 밟으면 자동으로 점프되며 Jump수치가 오르고, 1골드를 획득할 수 있습니다.
* 점수는 시간과 비례하며 증가합니다.
* 결승점은 플레이어가 일정 점수를 넘기면 바닥타일에 등장합니다. 게임 클리어를 위해서는 이 결승선을 통과해야 됩니다.
* 플레이어가 너무 위에 있어 결승선을 통과하지 못했을 경우 결승점은 일정 점수 마다 재등장합니다.
* 플레이어는 스테이지를 클리어하기 위해서 적절한 타이밍에 땅바닥으로 내려와 결승점을 통과해야 합니다.
* Jump 수치는 점프를 할 수 있는 양입니다.
* 아이템을 먹었거나 연속적 몬스터를 밟아 Jump수치를 2 이상 채웠을 경우 공중점프가 가능합니다. 다만 Jump수치는 땅을 밟으면 1로 초기화됩니다.

![GameScene2](https://user-images.githubusercontent.com/37152976/114378064-4942b000-9bc2-11eb-8c65-d3beb8d3e54d.gif)

* 6단계의 다양한 스테이지를 개발했으며, 각 스테이지마다 테마와 발판 방식이 달라집니다. 
* 스테이지에 따라 조금씩 다른 열매가 등장합니다.
* Jump수치가 100이된것은 조건에 맞추어져 스킬이 발동된 것 입니다.

![GameScene3](https://user-images.githubusercontent.com/37152976/114378108-5790cc00-9bc2-11eb-85d4-9a29240a65d7.gif)


* 유저 인터페이스와 환경설정까지 구현하여 시스템 볼륨과 배경음악을 줄이거나 키울 수 있습니다.
* Copyright에는 해당 게임에 사용한 무료 사운드 출처를 집어 넣었습니다.


![Start](https://user-images.githubusercontent.com/37152976/115267226-e6c65280-a173-11eb-9273-a52e032e171c.png)

* 구글 출시 화면


## 2 프로젝트 구조
게임 특성상 서버의 필요성은 없다고 판단되어 별도의 서버없이 유저 정보와 게임의 기본적인 데이터 파일을 ToBase64String함수를 사용하여 json파일로 기기내에 암호화하여 저장후 사용하고 있습니다.
게임내 몬스터나 지형의 기본 동작구조는 똑같기에 옵저버 패턴으로 동작구조를 제작한 뒤에 각각의 특색들은 인터페이스기반 데코레이터 패턴을 사용하여 코딩의 효율성을 높였습니다.
몇몇 몬스터들은 플레이어가 자신의 시야범위안에 들어온다면 특정 행동을 취하는 패턴이 내장되어 있습니다.  

### 몬스터 생성
![Honeycam 2021-08-26 23-56-17](https://user-images.githubusercontent.com/37152976/130986558-d6e5d1a8-5dfe-4415-912b-5a132a51fb69.gif)
무한히 생성되는 몬스터와 지형 특성상 과도하게 오버플로우가 일어날 것을 대비해 다음과 같은 로직을 구현했습니다.  

1) 먼저 이번 라운드가 시작되면 라운드에 생성된 몬스터의 가짓수를 목록으로 가져옵니다. 현 게임 환경에서는 라운드마다 2~3종류의 각기 다른 몬스터가 출현합니다.  
2) 15개 정도의 메모리 목록에 몬스터들을 미리 배정해놓은 뒤 목록을 생성해놓고 준비시킵니다.  
  2-1) 첫 3개의 메모리에는 3종류의 몬스터가 확정적으로 들어가며 나머지 메모리에는 랜덤으로 자동적으로 부과됩니다.  
3) 메모리 목록에서 순차적으로 몬스터들을 플레이어 시야 밖에서 소환합니다.   
  3-1) 단 랜덤 간격을 두고 몬스터들이 소환되자마자 삭제당합니다.  
  3-2) 몬스터가 소환되면 메모리는 "사용 가능"에서 "사용중"으로 바뀝니다.  
4) 플레이어의 시야 밖으로 가면 몬스터는 삭제됩니다.  
5) 삭제되거나 플레이어에게 밟혀 죽은 몬스터의 메모리는 다시 "사용 가능"으로 바뀌어 소환대기 목록에 올라갑니다.  
  
몬스터마다 메모리공간을 잡아놓고 랜덤간격으로 몬스터를 삭제하는 이유는 후반에 똑같은 패턴으로만 몬스터가 나오는것을 방지하기 위함이다.  
이렇게 몬스터들은 무규칙 적으로 나오게 되고 플레이의 긴장감을 올려주려고 노력했다.  
이 패턴은 순전히 내 아이디어에서 나왔음으로 엉성하고 의문이 가는 부분도 있겠지만, 그래도 [오버플로우 없이 몬스터가 무한히 랜덤 출현] 이라는 원하는 결과에 도달했기에 만족이 들었다.  
  


# 마치며

## 프로젝트 보완사항  
 본 프로젝트는 우선 최적화와 보안 측면에서 부족한 부분이 많습니다. 가족들 폰으로 테스트해본 결과 몇몇 폰에서는 동작이 안되는 현상을 발견해 조금씩 수정하고 있습니다. 대부분의 로직이나 구현방법이 혼자 생각해서 만들었기에 엉성한 부분이 많습니다. 하지만 전체적인 큰 줄기가 완성됐다는것에 의의를 두고 이번 경험을 통해 다음 작품에는 더 나은 프로젝트를 만들 수 있을 것 같다는 자신감이 생겼습니다.  
 
 ## 소감  
 처음부터 게임이 러닝액션게임으로 결정된 건 아니였습니다. 처음 시작한 게임은 RPG였다가 방대한 양의 그래픽작업에 포기했고 그 다음은 FPS 형식 1인 액션게임이였는데 이 또한 3D 그래픽의 경지를 경험한 뒤 초기 시안만 만들어지고 폐기되었습니다. 결국은 가장 쉬운 도트 그래픽으로 정한 뒤에 다시 한번 RPG 형식을 도전했다가 도트 그래픽조차 만만치 않음을 느끼고 저의 그래픽적 한계를 절실하게 느꼈습니다.   
 최종적으로 러닝액션게임으로 기획되었습니다. 적은 그래픽으로 단순 반복을 피하기 위해 랜덤생성 로직에 시간을 쏟았습니다. 한정된 자원으로 개발하면서 프로그래밍적으로 부족한 부분을 채워야 했고, 그 과정에서 수많은 실패도 뒤따랐습니다. 하지만 모든 걸 넘어서서 결국엔 플레이 스토어에 등록하면서 끝을 보게 되었습니다.   
 많이 부족한 프로젝트이지만 저로서는 새로운 기능들이 필요하면 언제든지 찾아보고 습득하는 연습이 되었고 앞으로 스스로 성장하는 방법을 일깨워준 프로젝트가 되었습니다.  




   
   
   
   



